package pl.piotrsukiennik.tuner.service.statement.wrapper;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import pl.piotrsukiennik.tuner.DataSource;
import pl.piotrsukiennik.tuner.Sharder;
import pl.piotrsukiennik.tuner.dto.DataRetrieval;
import pl.piotrsukiennik.tuner.exception.DataRetrievalException;
import pl.piotrsukiennik.tuner.exception.QueryParsingNotSupportedException;
import pl.piotrsukiennik.tuner.model.query.Query;
import pl.piotrsukiennik.tuner.model.query.ReadQuery;
import pl.piotrsukiennik.tuner.model.query.WriteQuery;
import pl.piotrsukiennik.tuner.model.query.WriteQueryExecution;
import pl.piotrsukiennik.tuner.persistance.DaoHolder;
import pl.piotrsukiennik.tuner.service.QueryParserService;
import pl.piotrsukiennik.tuner.service.statement.InterceptorDataSource;
import pl.piotrsukiennik.tuner.service.util.Statements;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;

/**
 * @author Piotr Sukiennik
 * @date 15.02.14
 */
public class PSExecutionIntercepting<T extends PSParametersIntercepting<?>> extends PSWrapper<T> {

    private static final Log LOG = LogFactory.getLog( PSExecutionIntercepting.class );

    private String PARSER_ERROR_FORMAT = "Query \"%s\" is not supported by parser - returning default execution PreparedStatement.%s()";

    private String PARSER_WRITE_ERROR_FORMAT = "Query \"%s\" is not supported by parser - ignored.";


    protected Sharder sharder;

    protected QueryParserService parserService;

    protected String database;

    protected String schema;

    protected String sql;

    public PSExecutionIntercepting( T preparedStatement, Sharder sharder, QueryParserService parserService, String database, String schema, String sql ) {
        super( preparedStatement );
        this.sharder = sharder;
        this.parserService = parserService;
        this.database = database;
        this.schema = schema;
        this.sql = sql;
    }


    protected void logException( QueryParsingNotSupportedException exception, String query, String method ) {
        if ( LOG.isErrorEnabled() ) {
            LOG.error( String.format( PARSER_ERROR_FORMAT, query, method ), exception );
        }
    }

    protected void logWriteException( QueryParsingNotSupportedException exception, String query ) {
        if ( LOG.isErrorEnabled() ) {
            LOG.error( String.format( PARSER_WRITE_ERROR_FORMAT, query ), exception );
        }
    }


    protected <T extends Query> T getQuery( String sql ) throws QueryParsingNotSupportedException {
        String sqlQueryWithParams = Statements.bind( sql, preparedStatement.getParameterSet() );
        return (T) parserService.parse( database, schema, sqlQueryWithParams );
    }


    protected void proceed( boolean affected ) {
        proceed( affected ? 1 : 0 );
    }

    protected void proceed( int rowsAffected ) {
        try {
            WriteQuery query = getQuery( sql );
            proceed( query, rowsAffected );
        }
        catch ( QueryParsingNotSupportedException e ) {
            logWriteException( e, sql );
        }
    }

    protected void proceed( String sql, boolean affected ) {
        proceed( sql, affected ? 1 : 0 );
    }

    protected void proceed( String sql, int rowsAffected ) {
        try {
            WriteQuery query = getQuery( sql );
            proceed( query, rowsAffected );
        }
        catch ( QueryParsingNotSupportedException e ) {
            logWriteException( e, sql );
        }
    }

    protected void proceed( WriteQuery query, int rowsAffected ) {
        WriteQueryExecution writeQueryExecution = new WriteQueryExecution();
        writeQueryExecution.setRowsAffected( rowsAffected );
        writeQueryExecution.setTimestamp( new Timestamp( System.currentTimeMillis() ) );
        writeQueryExecution.setQuery( query );
        DaoHolder.getCommonDao().create( writeQueryExecution );
        if ( rowsAffected > 0 ) {
            sharder.delete( query );
        }
    }

    //WRITE EXECUTIONS

    @Override
    public int[] executeBatch() throws SQLException {
        return super.executeBatch();
    }


    @Override
    public boolean execute( String sql, String[] columnNames ) throws SQLException {
        boolean rowsAffected = super.execute( sql, columnNames );
        proceed( sql, rowsAffected );
        return rowsAffected;
    }


    @Override
    public int executeUpdate( String sql, int autoGeneratedKeys ) throws SQLException {
        int rowsAffected = super.executeUpdate( sql, autoGeneratedKeys );
        proceed( sql, rowsAffected );
        return rowsAffected;
    }

    @Override
    public int executeUpdate( String sql, int[] columnIndexes ) throws SQLException {
        int rowsAffected = super.executeUpdate( sql, columnIndexes );
        proceed( sql, rowsAffected );
        return rowsAffected;
    }

    @Override
    public int executeUpdate( String sql, String[] columnNames ) throws SQLException {
        int rowsAffected = super.executeUpdate( sql, columnNames );
        proceed( sql, rowsAffected );
        return rowsAffected;
    }

    @Override
    public boolean execute( String sql, int autoGeneratedKeys ) throws SQLException {
        boolean affected = super.execute( sql, autoGeneratedKeys );
        proceed( sql, affected );
        return affected;
    }

    @Override
    public boolean execute( String sql, int[] columnIndexes ) throws SQLException {
        boolean affected = super.execute( sql, columnIndexes );
        proceed( sql, affected );
        return affected;
    }

    @Override
    public int executeUpdate() throws SQLException {
        int affected = super.executeUpdate();
        proceed( affected );
        return affected;
    }

    @Override
    public boolean execute( String sql ) throws SQLException {
        boolean affected = super.execute( sql );
        proceed( sql, affected );
        return affected;
    }


    @Override
    public int executeUpdate( String sql ) throws SQLException {
        int affected = super.executeUpdate( sql );
        proceed( sql, affected );
        return affected;
    }

    @Override
    public boolean execute() throws SQLException {
        boolean affected = super.execute();
        proceed( affected );
        return affected;

    }

    //!WRITE EXECUTIONS

    //READ EXECUTIONS

    protected ResultSet getResultSet( ReadQuery readQuery, DataSource rootDataSource ) throws SQLException {
        try {
            sharder.setRootDataForQuery( readQuery, rootDataSource );
            DataRetrieval dataRetrieval = sharder.getData( readQuery );
            return dataRetrieval.getResultSet();
        }
        catch ( DataRetrievalException e ) {
            DaoHolder.getLogDao().logException( readQuery.toString(), e );
            throw new SQLException( e );
        }
    }

    @Override
    public ResultSet executeQuery( final String sql ) throws SQLException {
        try {
            ReadQuery readQuery = getQuery( sql );
            DataSource rootDs = new InterceptorDataSource( this, readQuery ) {
                @Override
                protected ResultSet proceed() throws SQLException {
                    return PSExecutionIntercepting.super.executeQuery( sql );
                }
            };
            return getResultSet( readQuery, rootDs );
        }
        catch ( QueryParsingNotSupportedException e ) {
            logException( e, sql, "executeQuery(java.lang.String)" );
            return super.executeQuery( sql );
        }
    }

    @Override
    public ResultSet executeQuery() throws SQLException {
        try {
            ReadQuery readQuery = getQuery( sql );
            DataSource rootDs = new InterceptorDataSource( this, readQuery ) {
                @Override
                protected ResultSet proceed() throws SQLException {
                    return PSExecutionIntercepting.super.executeQuery();
                }
            };
            return getResultSet( readQuery, rootDs );
        }
        catch ( QueryParsingNotSupportedException e ) {
            logException( e, sql, "executeQuery()" );
            return super.executeQuery();
        }
    }

    @Override
    public ResultSet getResultSet() throws SQLException {
        try {
            ReadQuery readQuery = getQuery( sql );
            DataSource rootDs = new InterceptorDataSource( this, readQuery ) {
                @Override
                protected ResultSet proceed() throws SQLException {
                    return PSExecutionIntercepting.super.getResultSet();
                }
            };
            return getResultSet( readQuery, rootDs );
        }
        catch ( QueryParsingNotSupportedException e ) {
            logException( e, sql, "getResultSet()" );
            return super.getResultSet();
        }

    }

    //!READ EXECUTIONS


}
